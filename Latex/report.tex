
\documentclass[12pt,a4paper]{article}
\usepackage[pdftex]{graphicx} %for embedding images
\usepackage{url} %for proper url entries
\usepackage[bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={<pdf title here>}, pdfauthor={<author's name here>}, pdfsubject={<subject here>}, pdfkeywords={<keywords here>}]{hyperref} %for creating links in the pdf version and other additional pdf attributes, no effect on the printed document


\begin{document}


%include other pages
\input{./title.tex}



\pagenumbering{roman} %numbering before main content starts
\tableofcontents


\newpage
\pagenumbering{arabic} %reset numbering to normal for the main content

\section{Problem Definition}

The goal here is to create a basic dating website. We're using HTML, CSS, and JavaScript to build it. Simply put, we want to make a place where you can enter some info about yourself and then find someone who might be a good match for you among a bunch of students. It's all about making a website that's easy to use and helps people connect with each other.

\section{Basic Tasks}
Following are all the basic tasks that needed to be done.
\subsection{Login Page}
The project includes a login page feature, which acts as a gateway to access the input interface. Users are prompted to enter a username and password combination. If the entered credentials match those of a registered user stored in the "login.json" file, access is granted. Otherwise, appropriate error messages are displayed. This ensures that only registered users can access the website, even at a later time. The login page is implemented in a ".html" file named "login.html".
\subsection{“Forgot Password?” Button}
Additionally, the project incorporates a "Forgot Password?" feature to cater to instances where registered users forget their passwords. Upon clicking the designated "Forgot Password?" button on the login page, users are directed to a new page named "forgot.html" or, if integrated, remain on the login page itself. Here, users input their username, triggering the display of the corresponding secret question associated with the username from the "login.json" file. If the user correctly answers the secret question, the password is revealed on the screen. Otherwise, appropriate error messages are displayed, ensuring a streamlined password recovery process for registered users.
\subsection{Input Interface}

The task involves crafting an input interface using HTML and CSS for users to fill in their personal details. These details correspond to the fields in the "students.json" file, including "IITB Roll Number", "Name", "Year of Study", "Age", "Gender", "Interests", "Hobbies", "Email", and "Photo".
As customisation, I have also included 'Interested in' question to know the orientation of the user and display results accordingly.

For the "Gender" field, radio buttons are implemented to allow users to choose a single option. For "Interests" and "Hobbies", checkboxes are provided for users to select multiple options for each category.

Additionally, a "Submit" button is included, which, upon clicking, initiates the search for the person's ideal match. A "Logout" button is also provided to return users to the login screen for added convenience.

All of this functionality is designed and implemented within the "dating.html" file for the HTML structure and "style.css" file for the visual styling.
\subsection{Swiping}
A feature is added to the input interface to enable users to browse through all the students' profiles and photos stored in the "students.json" file. This page can be accessed through the navbar.

Upon clicking the button, users are directed to a new page named \\"scroll\textunderscore or\textunderscore swipe.html". This page allows users to freely scroll or swipe through profiles, viewing details and photos of each student in the dataset.

This page filters out the profiles according to the 'interested in' input provided by the user on the dating.html. 

\subsection{Finding the “right'' match}

The task involves improving the "Submit" button on the input interface ("dating.html") to find a suitable match for the user among the profiles in "students.json" using JavaScript. The match is based on shared interests and custom criteria. If no suitable match is found, an appropriate message is displayed. If there are multiple matches, one is chosen arbitrarily. The matchmaking process is flexible, adapting to individual preferences.

I used Jaccard's matching algorithm to generate the 'right' or we can say best match. This algorithm basically gives a number which is basically number of common interests/hobbies divided by total number of hobbies/interests. In other words size of intersection of their hobbies/interests divided by size of union of their hobbies/interests. greater the number of things common between two user... greater the score. To scale up the score, I have returned $\sqrt[2]{ original score}$
and then multiplied it by 100 to convert it in percentage. \\

\subsection{Output Interface}

After clicking "Submit," a new tab will display the "right match" for the person, including their details if a match is found. The interface for this is structured in a separate ".html" file named "match.html", utilizing the same CSS ("style.css") and JavaScript ("script.js") files.
On clicking submit in dating.html, first foundMatch.html is displayed. On hovering over the card in foundMatch.html, user can see the match. In case there is no match... The script leads the user to another webpage where an appropriate message is displayed.

\section{Customisations}
\subsection{Search}
It is a basic user search operation. With this feature, users can browse through potential matches by inputting specific names or keywords, enabling them to find individuals they are interested in connecting with.
\begin{itemize}
    \item HTML pages involved \begin{itemize}
        \item \texttt{search.html}: It will display the search results.
        \item \texttt{defaultSearch.html}: This is the default page for search. This page opens when search on navigation bar is clicked.
        \item \texttt{noResultFound}: This page appeaars if there is no person matching the keywords entered by the user.
        \item \texttt{searchResult}: This page displays the student on which the user clicked on while on \texttt{search.html} 
    \end{itemize}
    \item JavaScript functions involved: \begin{itemize}
        \item \texttt{searchFun()}
        \item \texttt{renderSearch()}
        \item \texttt{renderSearchResult}
    \end{itemize}
\end{itemize}
At first, what the search function does is taking the input from the user and after that constructs valid regular expressions based on that input for checking each name entered by a user. When a user’s name is discovered through matching such regular expressions, there will appear clickable divisions having names listed alongside other necessary information about the individual named. The full information for every specific user can be displayed by clicking on any of these divisions on the page. These is achieved by storing their data in local storage and then rendering it.
\subsection{Sending mail to the right match}
With this feature any user can a message to his or her 'Perfect' match. The 'Perfect Mail' can recieve the mail from justvingh@gmail.com. The perfect match can choose to reply and the reply will be sent to the user that sent the inital message.\begin{itemize}
    \item HTML page involved: \begin{itemize}
        \item \texttt{email.html}: This page can be opened by clicking on the 'Message' button present in \texttt{match.html}. 
    \end{itemize}
    \item Function involved:\begin{itemize}
        \item \texttt{sendEmail(email,name,matchEmail,matchName, message)}
    \end{itemize}
This function works using EmailJs library. I made the template on \underline{\href{https://www.emailjs.com/}{this website}}. Code for this feature(both CSS and JavaScript) is written in the HTML file to avoid conflicts in importing two JavaScript files(JavaScript file used in send mails is \underline{\href{https://cdn.emailjs.com/dist/email.min.js}{https://cdn.emailjs.com/dist/email.min.js}}).      
\end{itemize}
\subsection{Cookies}
\subsection{Filters}
By adding filters based on interests, hobbies, year of study, and gender, we're making the matchmaking experience feel more personal. Users can now narrow down their search to find profiles that really resonate with them. This means when they're scrolling or swiping, they'll only see profiles that match their preferences, making it easier for them to find someone they connect with.
\begin{itemize}
    \item HTML page involved:\begin{itemize}
        \item Nothing exclusively for this feature. Incorporated in \texttt{scroll\_or\_swipe.html}.
    \end{itemize}
    \item JavaScript functions involved: \begin{itemize}
        \item \texttt{checkFilter(person, filter)}
        \item \texttt{removeFilters()}
        \item \texttt{openFilterBar()}
        \item \texttt{closeFilterBar()}
        \item \texttt{FilterFunction()}
    \end{itemize}
\end{itemize}
First, i take the input from the \texttt{scroll\_or\_swipe.html}. Then i check every user if they follow those filters.  
\subsection{Profile Page}
\subsection{Sexual Orientation of user}






\section{JavaScript Code}
I've implemented 26 functions, all coded in script.js. Some JavaScript is also present in HTML pages, such as Left NavBar functionality.
\\
Following is the brief description of every function used:

\subsection{\texttt{submitHandler()}}
\begin{itemize}
    \item Gets called when the submit button is pressed on the dating.html page.
    \item Takes in the input filled by the user and calls \texttt{findMatch()}.
    \item Stores the input provided by the user in local storage in the form of JavaScript object. 
\end{itemize}

\subsection{\texttt{findMatch()}}
\begin{itemize}
    \item This function is called when the \texttt{submitHandler()} function is executed.
    \item It fetches the \texttt{students.json} file.
    \item Converts the response into a JavaScript object.
    \item Iterates through the object, calculating compatibility scores between the user and each student.
    \item Redirects to \texttt{foundMatch.html} upon completion.
    \item Converts the matched student data into a JSON string and stores it in local storage.
\end{itemize}

\subsection{\texttt{renderMatchFound()}}
\begin{itemize}
    \item This function renders the match on the \texttt{matchFound.html} page.
    \item It retrieves the matched student data from local storage.
    \item Checks if the compatibility score is below 0.4, it redirects to \texttt{sorry.html}.
    \item Displays the matched student's name, image, and compatibility score.
\end{itemize}

\subsection{\texttt{renderMatch()}}
\begin{itemize}
    \item This function renders the details of the matched student on the \texttt{match.html} page.
    \item It retrieves the matched student data from local storage.
    \item Displays the matched student's name, interests, hobbies, age, image, IITB roll number, year of study, and gender.
\end{itemize}

\subsection{\texttt{scoreCalculator(user1, user2)}}
\begin{itemize}
    \item This function calculates the compatibility score between two users.
    \item It implements Jaccard's Algorithm to calculate the score based on shared interests and hobbies.
    \item Returns the compatibility score scaled to a percentage.
\end{itemize}

\subsection{\texttt{onLogin()}}
\begin{itemize}
    \item This function is triggered when the login button is clicked.
    \item Fetches the \texttt{login.json} file.
    \item Verifies the entered username and password.
\end{itemize}

\subsection{\texttt{checkLoginData(data)}}
\begin{itemize}
    \item This function verifies the user's login credentials and displays appropriate error messages.
    \item Retrieves the input username and password.
    \item Checks if the username exists and if the password matches the username.
\end{itemize}

\subsection{\texttt{findSecret()}}
\begin{itemize}
    \item This function retrieves a user's secret question based on their username.
    \item Fetches the \texttt{login.json} file.
    \item Displays the user's secret question if the username exists.
\end{itemize}

    \subsection{\texttt{checkSecretAnswer()}}
\begin{itemize}
    \item This function checks the user's secret answer for password recovery.
    \item Retrieves the entered answer and username.
    \item Compares the entered answer with the stored secret answer for the given username.
\end{itemize}

\subsection{\texttt{checkFilter(person, filter)}}
\begin{itemize}
    \item This function gets called when someone applies a filter.
    \item It takes \texttt{filter} and \texttt{person} as input and returns if the person passes the filter.
\end{itemize}


\subsection{\texttt{scroll()}}
\begin{itemize}
    \item This function renders everyone (who matches the filters) in the scroll-container.
    \item It is called when \texttt{scroll\textunderscore or\textunderscore swipe.html} is loaded.
\end{itemize}


\subsection{\texttt{removeFilters()}}
\begin{itemize}
    \item This function removes filters applied to the scroll-container.
    \item It redirects back to \texttt{scroll\textunderscore or\textunderscore swipe.html}.
\end{itemize}

% Function for logging out
\subsection{\texttt{logoutFun()}}
\begin{itemize}
    \item This function is called when logout is clicked on the navbar.
    \item It removes all data stored in the local storage to prevent any conflicts if a different user logs in.
\end{itemize}

% Function for opening the filter bar
\subsection{\texttt{openFilterBar()}}
\begin{itemize}
    \item This function is called when the filter button in the \texttt{scroll\_or\_swipe.html} page is clicked.
    \item It opens the filter bar by adjusting its height and changes the appearance of the filter button.
\end{itemize}

% Function for closing the filter bar
\subsection{\texttt{closeFilterBar()}}
\begin{itemize}
    \item This function is called when the filter button in the \texttt{scroll\_or\_swipe.html} page is clicked and the filter bar is open.
    \item It closes the filter bar by adjusting its height and changes the appearance of the filter button.
\end{itemize}

% Function for applying filters
\subsection{\texttt{FilterFunction()}}
\begin{itemize}
    \item This function is called when the filter button is clicked in the filter bar in the \texttt{scroll\_or\_swipe.html} page.
    \item It collects the interests and hobbies selected by the user and stores them in local storage as \texttt{filterData}.
    \item It then redirects to the \texttt{scroll\_or\_swipe.html} page.
\end{itemize}

% Function for rendering user details
\subsection{\texttt{renderOwnDetails()}}
\begin{itemize}
    \item This function is triggered when the user clicks on home when on any page other than \texttt{dating.html}.
    \item It retrieves the user's details and image from local storage and displays them on the page.
\end{itemize}

% Function for scrolling the scroll container
\subsection{\texttt{scroll\_the\_scroll\_container(e)}}
\begin{itemize}
    \item This function is called when the user presses any key on the \texttt{scroll\_or\_swipe.html} page.
    \item If the right arrow key is pressed, it scrolls the scroll-container to the next box, displaying the next user.
    \item If the left arrow key is pressed, it scrolls the scroll-container to the previous box, displaying the previous user.
\end{itemize}

\subsection{\texttt{setCookie()}}
\begin{itemize}
    \item This function sets a cookie named \texttt{username} with the value of the input field with the ID \texttt{username}.
    \item The cookie expires after 1 hour.
\end{itemize}

% Function for getting a cookie
\subsection{\texttt{getCookie(key)}}
\begin{itemize}
    \item This function retrieves the value of the cookie with the specified \texttt{key}.
\end{itemize}

% Function for checking if a cookie exists
\subsection{\texttt{checkCookie()}}
\begin{itemize}
    \item This function checks if the \texttt{username} cookie exists.
    \item If the cookie exists, it redirects the user to the \texttt{scroll\_or\_swipe.html} page.
    \item If the cookie does not exists, it clears the local storage.
    \item This function if for the \texttt{login.html} and \texttt{forget.html}
\end{itemize}

% Function for checking if a cookie exists on pages requiring authentication
\subsection{\texttt{checkCookiePages()}}
\begin{itemize}
    \item This function checks if the \texttt{username} cookie exists.
    \item If the cookie doesn't exist, it redirects the user to the \texttt{login.html} page and displays a prompt to log in.
    \item This function is for all the pages other than \texttt{login.html} and \texttt{forget.html}
\end{itemize}


\subsection{\texttt{removeFilterButton()}}
\begin{itemize}
    \item This function checks if any filters are applied.
    \item If no filters are applied, it hides the remove filters button.
\end{itemize}

\subsection{\texttt{searchFun()}}
\begin{itemize}
\item Retrieves the search query from the input field.
\item Constructs a regular expression pattern based on the search query.
\item Fetches student data from the \texttt{students.json} file.
\item Filters the student data based on the search query using the regular expression pattern.
\item Stores the filtered results in local storage and redirects to the \texttt{search.html} page.
\end{itemize}

\subsection{\texttt{renderSearch()}}
\begin{itemize}
\item Retrieves search results from local storage.
\item Redirects to \texttt{noResultFound.html} if no results are found.
\item Dynamically creates HTML elements to display search results including student name, image, age, year of study, etc.
\item Sets up event listeners to handle clicks on search results, storing the selected student's data in local storage and redirecting to \texttt{searchResult.html}.
\end{itemize}

\subsection{\texttt{renderSearchResult()}}
\begin{itemize}
\item Retrieves the selected student's data from local storage.
\item Dynamically populates HTML elements with the selected student's details such as name, interests, hobbies, age, etc.
\end{itemize}






% \input{./introduction.tex} %literature survey included in this
% \input{./work-done.tex}
% \input{./future-work.tex}
% \input{./conclusion.tex}
% \input{./acknow.tex}
% \input{./ref.tex}

\end{document}
